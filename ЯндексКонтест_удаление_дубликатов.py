# Марсоход берёт пробы грунта, определяет тип горных пород и записывает полученные данные в отсортированный массив.
# Каждый тип горной породы обозначается целым числом.
#
# Массив отсортирован в порядке возрастания: значения идут от меньшего к большему.
# В массиве могут быть дублирующиеся значения, ведь в разных пробах могут встречаться одни и те же горные породы.
#
# Ваша задача — написать программу, удаляющую дубликаты из этого массива:
# каждый элемент должен встречаться в массиве только один раз.
# При этом относительный порядок элементов должен остаться прежним.
#
# Дублирующие значения нужно заменить на символ подчёркивания.
#
# После выполнения преобразований массив должен остаться такого же размера, как и был.
# В начале массива должны находиться уникальные элементы, а после них — элементы,
# содержащие символ подчёркивания. Эти элементы должны быть строго в конце массива, не между числами.


# Формат ввода
# В первой строке записано целое число n — это длина массива, переданного во второй строке.
# Во второй строке записано n натуральных чисел, разделённых пробелами.
#
# Формат вывода
# Уникальные числа из исходного массива по возрастанию и символы подчёркивания.
# Элементы должны быть разделены пробелами. Общее количество элементов должно быть равно n.

# Пример:

# Ввод
# 10
# 0 0 1 1 1 2 2 3 3 4

# Вывод
# 0 1 2 3 4 _ _ _ _ _

def main():
    # Считали первую строку ввода и сразу привели к числу.
    elements_count = int(input())
    # Считали вторую строку ввода и сразу привели к списку.
    first_array = input().split()
    # Инициализируем пустой список для сохранения результата.
    result = []


    # c = list(set(first_array) & set(b))
    # print(c)

    # Чтобы получить каждый дубликат только один раз, можно использовать множества:
    visited = set()  # пустое множество

    # Количество повторений
    dup = {int(x) for x in first_array if
           x in visited or (visited.add(x) or False)}
    print(type(dup))
    print(dup)

    # Количество уникальных символов
    uniq = {int(x) for x in first_array if
            x not in dup or (visited.add(x) or False)}
    print(type(uniq))  # тип set - множество
    print(uniq)

    uniq_list = list(uniq)  # список дубликатов (отсортированный)
    print(*uniq_list)  # распаковка списка, разделитель - пробел

    result = list(set(first_array) - uniq)
    print(result)


    #result = list[item for item in A if item not in Bset]  # C = A - B

    # for i in first_array:
    #     if not (i in uniq_list):
    #         result.append(i)
    # print('_'.join(result))


    # Создаём цикл по количеству элементов в массиве.
    # for element in range(dup):
    #     if element in uniq_list:
    #         result.extend(uniq_list)
    # print(result)
    # #print(' '.join(result))






if __name__ == '__main__':
    # Решение оформлено в функцию, эту функцию надо обязательно вызвать:
    # Яндекс Контест не сможет вызвать её сам.
    main()







# import sys
#
# # Прочитали первую строку, в которой указано количество строк,
# # преобразовали в число:
# num_lines = int(sys.stdin.readline().rstrip())  # нужно самому ввести данные
#
#
# # for item in ordered_list:    # for item in range(num_massiv):
# #         if item == element:
# #             element = "_"
# #             return f'Элемент {desired_element} найден в массиве!'
# #         elif item > desired_element:
# #             return f'Элемент {desired_element} не найден в массиве.'
# #         break
# #     return f'Элемент {desired_element} не найден в массиве.'
#
#
# # Вызываем функцию с тестовыми данными.
# # Первый аргумент - целое число.
# # Второй аргумент - отсортированный по возрастанию список целых чисел.
# result = check_element_in_sorted_list(10, [0, 0, 1, 1, 1, 2, 2, 3, 3, 4])
# # Распечатываем результат.
# print(result)


