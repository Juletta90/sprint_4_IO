## Создадим накопительную сумму, которая покажет,
# сколько раз в массиве встретились положительные значения:

# -1, -4, 8, -7, 3, 0, 1, -7, -7, 0, 0, -4, 1      # Исходный массив.
#  0   0  0   1  1  2  2   3   3  3  3   3  3  4   # Накопительная сумма.
#
# # Около значения 8 стоит накопительная сумма 0:
# # до восьмёрки не было положительных значений,
# # а текущий элемент не учитывается.
# # Единичка в счётчике "накопилась" только на следующем элементе.


# Если для массива определена накопительная сумма, можно легко узнать
# количество нужных элементов на участке массива, ограниченном
# индексами left и right (правый индекс не включается в диапазон):
# из накопительной суммы для индекса right нужно вычесть
# накопительную сумму для индекса left.

#  0   1  2   3  4  5  6   7   8  9  10  11 12 13    # Индексы массивов.
# -1, -4, 8, -7, 3, 0, 1, -7, -7, 0, 0, -4, 1        # Исходный массив.
#  0   0  0   1  1  2  2   3   3  3  3   3  3  4     # Массив с накопительной суммой.

# Исходный массив
data = [-1, -4, 8, -7, 3, 0, 1, -7, -7, 0, 0, -4, 1]
# Накопительная сумма
cumulative_sums = [0, 0, 0, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 4]

left = 2
right = 6
result = cumulative_sums[right] - cumulative_sums[left]
# 2 - 0 == 2
# В диапазоне между элементами с индексами 2 и 6
# положительные значения встречаются два раза.

# можно взять len(data) — это значение всегда на единицу
# больше последнего индекса. И, обрати внимание, в качестве
# cumulative_sums[right] будет взято значение из последнего,
# «дополнительного» элемента массива с накопительной суммой.



# На этом массиве потестируем мою программу:
days_temp = [-1, -4, 8, -7, 3, 0, 1, -7, -7, 0, 0, -4, 1, 8, 1, -5, 4, 0, 7, 1]

# Мне понадобится пустой список, я в него буду записывать накопительную сумму.
# Первым элементом будет ноль, ведь искомых значений пока не найдено:
# мы ещё не начали поиск.
cumulative_sums = [0]


def calculate_cumulative_sums(sequence):
    # Создаю счётчик. Буду его наращивать на 1, когда
    # обнаружу положительное значение в массиве.
    # Значение счётчика на каждой итерации буду записывать в cumulative_sums.
    count = 0
    # Вычисляю накопительную сумму для массива:
    for item in sequence:
        # Если обнаружилось положительное значение...
        if item > 0:
            # ...увеличиваю счётчик на единицу:
            count += 1
        # Добавляю очередной элемент к списку с накопительной суммой:
        cumulative_sums.append(count)


def calculate_positive(left, right):
    # Теперь получаю количество искомых значений
    # на любом участке массива - просто выполняю вычитание:
    return cumulative_sums[right] - cumulative_sums[left]


calculate_cumulative_sums(days_temp)
print(calculate_positive(10, 19))
print()


#___________________________ООП__________________________________________

# Напишем класс Sequence. Список с накопительной суммой self.cumulative_sums
# создаём в конструкторе класса и сохраняем как атрибут экземпляра,
# а не как объект в глобальной области.
# У метода calculate_positive() будет доступ к списку с накопительной
# суммой self.cumulative_sums. При вызове этот метод подсчитает
# положительные значения между индексами left и right и вернёт результат.

days_temp = [-1, -4, 8, -7, 3, 0, 1, -7, -7, 0, 0, -4, 1, 8, 1, -5, 4, 0, 7, 1]


class Sequence:

    def __init__(self, sequence):
        # Список с накопительной суммой, для первого элемента она равна 0.
        self.cumulative_sums = [0]
        count = 0
        # Вычисляем накопительную сумму для массива:
        for i in sequence:
            # Если нашлось положительное значение...
            if i > 0:
                # ...увеличиваем счётчик:
                count += 1
            # Добавляем очередной элемент к списку с накопительной суммой.
            self.cumulative_sums.append(count)

    def calculate_positive(self, left, right):
        # Чтобы посчитать количество положительных значений
        # на любом участке массива, просто выполняем вычитание.
        return self.cumulative_sums[right] - self.cumulative_sums[left]


s = Sequence(days_temp)
# Покажет количество положительных чисел в интервале от 10 до 19 -
# с 10-го по 18-й элемент включительно.
print(s.calculate_positive(10, 19))

# Применение накопительной суммы потребовало проведения
# «подготовительной работы», но упростило и ускорило подсчёт нужных элементов:
# Потребовалось провести подсчёт накопительной суммы.
# Временная сложность этой операции — линейная, O(n).

# Получить решение для определённого участка теперь можно за одно действие:
# достаточно выполнить вычитание. Эта операция занимает константное время O(1).

# Новый алгоритм увеличил расход памяти: теперь она расходуется не константно,
# как было в первом решении, а линейно.
# Для каждого элемента входного массива пришлось
# создать новый элемент в массиве с накопительной суммой.


