# Пузырьковая сортировка в коде Python

# Пусть data — массив для сортировки. Индекс последнего элемента
# массива будет равен len(data) - 1.

# При первом проходе потребуется сравнить попарно все элементы массива,
# включая и последний. На втором проходе надо сравнить все элементы,
# кроме последнего, на третьем — исключив из сравнения два последних.

# На каждом проходе сравниваем всё меньше элементов, последовательно
# исключая из проверок элементы в конце массива. С каждым проходом
# правая граница — предел, до которого проводятся сравнения элементов, —
# будет сдвигаться влево.

# Обозначим правую границу как last_index, в ней будет храниться индекс
# последнего элемента, который участвует в очередном проходе.
# В первом проходе значение last_index будет равно индексу последнего
# элемента: len(data) - 1. После каждого прохода значение last_index будет
# уменьшаться на единицу.

# Переменной item_index обозначим индекс элемента, значение которого
# в текущий момент сравнивается со значением следующего (item_index + 1)
# элемента в массиве. Сравнение элементов начинается с первого элемента
# в массиве, значит, в начале сортировки item_index = 0.

# Создадим булеву переменную, «флаг» swapped, она будет указывать,
# менялись ли местами элементы при текущем проходе по массиву:
# перед проходом устанавливаем swapped = False, а при первом же изменении
# порядка элементов меняем значение переменной на True.


# Приступаем к первому проходу по массиву:

# 1. Устанавливаем значение флага swapped = False:
# проход по массиву ещё не начался, перестановок не было.

# 2. Сравниваем элементы с индексами item_index и item_index + 1.

# 3. Если элемент с индексом item_index больше, чем следующий за
#    ним элемент с индексом item_index + 1:
#     3.1. Меняем местами эти элементы массива:
#          data[item_index], data[item_index + 1] =
#                            data[item_index + 1], data[item_index].
#     3.2. Значение флага swapped меняем на True: отмечаем,
#          что совершена перестановка.

# 4. Добавляем к item_index единицу и переходим к сравнению
# следующей пары элементов (выполняем п. 2).

# 5. После того как проверка дошла до предпоследнего элемента в текущем
#    проходе (с индексом last_index - 1) и два последних элемента сверены,
#    проверяем флаг swapped: были ли перестановки в этом проходе.
#    5.1. Если swapped is True, уменьшаем last_index на
#         единицу и возвращаемся к первому шагу.
#    5.2. Если swapped is False, массив отсортирован, завершаем работу.

# В коде потребуется создать два цикла:

# - Во внутреннем цикле переменной item_index будут присваиваться
#   индексы от 0 до last_index, элементы будут попарно сравниваться и
#   при необходимости меняться местами.

# - Каждый раз, когда внутренний цикл выполнится до конца,
#   внешний цикл будет уменьшать last_index на единицу и вновь
#   запускать внутренний цикл. Внешний цикл должен выполняться до тех пор,
#   пока будет возвращаться swapped is True или пока
#   last_index не станет равен 1.

# Внешний цикл можно реализовать двумя способами:

# - Можно написать внешний цикл через for. Если массив окажется
#   отсортирован до того, как будут перебраны все элементы,
#   из цикла можно выйти при помощи ключевого слова break.

# - Можно написать внешний цикл через while.
#   Условием выхода из цикла будет swapped is False.


example_array = [6, 5, 3, 1, 8, 7, 2, 4]


def bubble_sort(data):
    swapped = False
    # внешний цикл для определения количества вызовов внутреннего цикла
    for last_index in range(len(data) - 1, 0, -1):
        if last_index == 0:
            break
        for inner_index in range(last_index):
            if data[inner_index] > data[inner_index + 1]:
                data[inner_index], data[inner_index + 1] = data[
                        inner_index + 1], data[inner_index]
                swapped = True
        if not swapped:
            break
    return data


print(bubble_sort(example_array))

