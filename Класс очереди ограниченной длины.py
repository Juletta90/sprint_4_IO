# Класс очереди назовём LimitedQueue. Очередь — это такая структура,
# элементы которой всегда извлекаются с одной стороны массива
# (с «головы», head), а добавляются — с другой (с «хвоста», tail).
#
# У очереди, которую мы пишем, должно быть ограничение по длине.
# Следовательно, у экземпляра класса LimitedQueue должны быть такие атрибуты:

#  - head (голова) — индекс, по которому извлекается элемент, если очередь не пустая;
#  - tail (хвост) — индекс, по которому добавляется элемент;
#  - max_n — максимально возможное количество элементов в очереди;
#  - size — размер очереди.

# Когда очередь пуста, то и голова, и хвост должны указывать
# на нулевой элемент списка. Если надо извлечь элемент — извлекаем элемент
# с индексом 0 (получим None, но что делать).

# Если надо добавить элемент — добавляем его на
# позицию [0]: это первый свободный индекс в массиве.


# При создании очереди с ограниченной длиной лучше сразу создать во
# внутреннем массиве нужное число элементов:
# queue = [None] * max_n. Это позволит не реаллоцировать
# внутренний массив при добавлении элементов.

class LimitedQueue:

    def __init__(self, max_n):
        self.max_n = max_n
        # Максимальная длина списка известна, значит,
        # можно инициализировать сразу все элементы списка,
        # чтобы не тратить время на реаллокацию.
        self.queue = [None] * self.max_n
        self.head = 0  # Голова указывает на индекс 0
        self.tail = 0  # Хвост указывает на индекс 0
        self.size = 0  # При создании очередь пуста, её длина - 0

    def is_empty(self):
        # Если очередь пуста, вернётся True, в противном случае - False.
        return self.size == 0

    def push(self, value):
        # Если количество элементов в очереди меньше максимального количества.
        if self.size < self.max_n:
            # Проверяем, не занято ли место,
            # куда мы пытаемся вставить элемент.
            if self.queue[self.tail] is not None:
                # Если занято, значит, мы собираемся перезаписать
                # самый старый элемент. В этом случае надо увеличить
                # индекс головы на единицу, чтобы после перезаписи старого
                # элемента голова указывала на следующий элемент:
                # теперь он будет "самым старым" в очереди.
                self.head += 1
                # Если индекс головы равен максимальному размеру очереди...
                if self.head == self.max_n:
                    # ...значит, голова должна снова указать на 0:
                    self.head = 0
            # Создаём новый элемент (value) с индексом, на который указывает хвост tail.
            self.queue[self.tail] = value
            # Увеличиваем значение индекса для хвоста на единицу,
            # чтобы следующий элемент добавить на следующий индекс.
            self.tail += 1
            # Если индекс хвоста равен максимальному размеру очереди...
            if self.tail == self.max_n:
                # ...значит, список заполнен до предела. Хвост должен снова указать на 0:
                # все следующие элементы будем добавлять в начало списка,
                # заменяя старые значения новыми.
                self.tail = 0

            # Пока массив не достиг предельной длины, при каждом добавлении элемента
            # увеличиваем переменную, считающую количество элементов.
            self.size += 1

    # Добавляем метод pop():
    def pop(self):
        # Если очередь пуста...
        if self.is_empty():
            # ...возвращаем None.
            return None
        # Получаем значение элемента с индексом, на который указывает head:
        value = self.queue[self.head]
        # Вставляем на место этого значения None:
        self.queue[self.head] = None
        # Значение head должно увеличиться на единицу или
        # "спрыгнуть на ноль", если его значение будет равно max_n.
        # Применим тот же трюк, что и с tail:
        self.head = (self.head + 1) % self.max_n
        # Уменьшаем счётчик элементов в очереди.
        self.size -= 1
        # Возвращаем значение, на которое указывала голова:
        return value


# После добавления элемента увеличиваем значение атрибута tail на единицу,
# чтобы записать следующий элемент в следующую ячейку.
# При каждом добавлении элемента проверяем, не достигло ли
# число элементов установленного предела.

# Если предел достигнут, переносим указатель tail на 0: при
# добавлении следующего элемента самый старый из существующих
# элементов списка (элемент с индексом 0) будет удалён, а на его
# место будет вписан новый.

# При замене старого элемента на новый надо сдвигать и указатель head:
# head указывал на самый старый элемент, именно его нужно
# было вернуть при вызове метода pop();
# но теперь самый старый элемент заменён на новый,
# и «старейшим» окажется следующий — нацеливаем head на него.
# Именно этим занимается блок if self.queue[self.tail] is not None.

# Для вычисления остатка от деления x на y
# (иногда говорят «взять x по модулю y») в Python применяют
# оператор %: 3 % 2 == 1, 4 % 2 == 0, 2 % 5 == 2, 5 % 15 == 5.

# Таким образом, пока tail + 1 меньше max_n, будет возвращаться
# значение tail + 1, а когда tail + 1 станет равно max_n,
# указателю tail будет присвоено значение 0.

#___________________________________________________________________
# максимальное значение длины очереди мы отсчитываем от единицы,
# а индексы считаются от нуля. Получается, что для очереди ёмкостью
# в 8 элементов максимально допустимый индекс будет 7.
#___________________________________________________________________



# Начинаем проверку! Создаём очередь с ограничением 8 элементов:
q = LimitedQueue(8)
q.push(1)  # Добавляем один элемент.
print('Очередь с одним элементом:', q.queue)
print('Длина очереди с одним элементом:', q.size)
# Добавляем ещё три элемента:
q.push(-1)
q.push(0)
q.push(11)
print('Очередь с четырьмя элементами:', q.queue)
print('Длина очереди с четырьмя элементами:', q.size)
print()

#____________________________________________________________________
# Проверяем работу кода c методом pop!
q = LimitedQueue(8)
# Наполняем с избытком:
for i in range(10):
    q.push(i + 1)
# Напечатаем:
print('В очередь с ограничением 8 добавили 10 элементов:', q.queue)

# Извлекаем:
value = q.pop()

# Печатаем:
print('Извлечено значение', value)
print('Очередь после извлечения одного элемента:', q.queue)
print('Размер очереди после извлечения одного элемента:', q.size)

