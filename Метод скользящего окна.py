# Для массива, состоящего из n целых чисел, найдите непрерывный
# подмассив (срез) заданной длины k, сумма значений в котором минимальна.
# Напечатайте эту сумму.

# Число k всегда больше нуля и меньше n.
# Например, даны:
# список [5, -3, -2, 10, 2, 7, 1, -6, 13],
# длина подмассива k = 4.

# Требуется найти такой срез из четырёх элементов, в котором
# сумма значений будет минимальна.
# __________________________________________________________________


# Наивный брутфорс — наш выбор! Ну, то есть я напишу наивное решение
# через перебор всех возможных вариантов. Складываем первые четыре элемента,
# потом следующие четыре — начиная со второго элемента.
# Сравниваем результаты, меньшее из значений запоминаем.
# Потом берём сумму значений, начиная с третьего элемента.
# Сравниваем с сохранённой.
# И так повторяем, пока список не кончится.


# _____________ВАРИАНТ 1 - НАИВНЫЙ_____________________________

# Импортируем число, заведомо большее, чем любая сумма элементов среза.
from sys import maxsize


def find_min_slice_sum(data, elements_in_slice):
    # В переменную min_sum будем сохранять наименьшую сумму,
    # полученную при сравнении двух срезов.
    # В начале работы программы сумма первого среза
    # должна быть признана минимальной и записана в min_sum
    # (ведь других сумм пока что нет).
    # Установим очень большое стартовое значение min_sum.
    min_sum = maxsize
    # Двигаемся от начала массива до последнего элемента,
    # от которого мы сможем взять срез нужной длины.
    for index in range(len(data) - elements_in_slice):
        # В temp_sum будем записывать сумму элементов очередного среза
        # и сравнивать её с min_sum.
        temp_sum = 0
        # Перебираем элементы в срезе.
        for slice_index in range(elements_in_slice):
            # Подсчитываем сумму значений в очередном срезе.
            temp_sum += data[index + slice_index]
        # Выбираем минимальное значение из двух и сохраняем это значение
        # в переменную min_sum.
        min_sum = min(min_sum, temp_sum)
    return min_sum


if __name__ == '__main__':
    data = [5, -3, -2, 10, 2, 7, 1, -6, 13]
    elements_in_slice = 4
    print(find_min_slice_sum(data, elements_in_slice))
    print()

# _____________________ВАРИАНТ 2______________________________
# напечатай все значения срезов.

data = [5, -3, -2, 10, 2, 7, 1, -6, 13]
elements_in_slice = 4

# Сперва посчитаю сумму элементов в первом срезе,
# с индексами от 0 до elements_in_slice:
window_sum = sum(data[0:elements_in_slice])
# Сразу напечатаю:
print(window_sum)


# Теперь переберу массив data по индексам,
# от второго элемента в массиве до (len(data) - elements_in_slice) включительно:
for index in range(1, len(data) - elements_in_slice + 1):
    # Считаю сумму для текущего среза:
    # к сумме предыдущего среза прибавляю
    # значение последнего элемента текущего среза...
    window_sum += data[index + elements_in_slice-1]
    # ...и вычитаю значение первого элемента предыдущего среза:
    window_sum -= data[index - 1]
    print(window_sum)
print()


#_______________ВАРИАНТ 3_________________________________

def find_min_slice_sum(data, elements_in_slice):
    # Считаем сумму первого окна.
    window_sum = sum(data[0:elements_in_slice])
    # Запоминаем результат подсчёта в качестве минимальной суммы.
    min_sum = window_sum
    # В цикле перебираем индексы массива от elements_in_slice до последнего.
    for index in range(elements_in_slice, len(data)):
        # К сумме предыдущего окна добавляем новый элемент: data[index]
        # и вычитаем "вышедший" элемент: data[index - elements_in_slice]
        window_sum += data[index] - data[index - elements_in_slice]
        # Находим минимальную сумму.
        min_sum = min(min_sum, window_sum)
    return min_sum


if __name__ == '__main__':
    data = [5, -3, -2, 10, 2, 7, 1, -6, 13]
    elements_in_slice = 4
    print(find_min_slice_sum(data, elements_in_slice))
