# В программном коде алгоритм поиска по несортированному массиву мог бы выглядеть так:

wins = [7495938, 1223125, 2128437, 4567890, 2128500, 2741001, 9314543, 4567687]
my_ticket = 2128506


def check_element_in_unordered_list(desired_element, unordered_list):
    """Проверяет наличие заданного элемента в неотсортированном списке."""
    # Итерируемся по списку.
    for item in unordered_list:
        # Каждый элемент сверяем с искомым.
        if item == desired_element:
            # Если элемент найден, то возвращаем значение True.
            return True
    # Если цикл прошёл, а элемент не найден, возвращаем False.
    return False


# Если функция вернула True...
if check_element_in_unordered_list(my_ticket, wins):
    # ...печатаем сообщение:
    print(f'Элемент {my_ticket} найден в списке!')
else:
    # Если функция вернула False - тоже сообщаем об этом.
    print(f'Элемент {my_ticket} не найден в списке.')


# Чтобы определить, есть ли искомое значение в списке, можно применить оператор in, проверяющий вхождение элемента в коллекцию.
# Выходит, можно одним выражением определить, есть ли нужный номер билета в списке: desired_element in unordered_list.
# Однако «под капотом» Python выполнит примерно те же операции, что и в приведённом коде, а значит, алгоритмически
# никакого выигрыша не будет: код станет короче, но на его выполнение потребуется примерно столько же ресурсов.
# «Примерно столько же» — потому что накладные расходы на вызов встроенной функции всегда несколько меньше,
# чем у решений, написанных разработчиком самостоятельно.

# Практический вывод прост: если есть возможность заменить цикл на встроенную функцию
# или операцию — лучше применить встроенные инструменты.